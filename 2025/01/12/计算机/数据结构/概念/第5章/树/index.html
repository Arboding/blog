<!-- build time:Mon Jan 13 2025 00:39:08 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><meta name="algolia-site-verification" content="C77F85937818B939"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/Arboding/blog@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/Arboding/blog@latest/images/favicon.ico"><link rel="mask-icon" href="//cdn.jsdelivr.net/gh/Arboding/blog@latest/images/logo.svg" color=""><link rel="manifest" href="//cdn.jsdelivr.net/gh/Arboding/blog@latest/images/manifest.json"><meta name="msapplication-config" content="//cdn.jsdelivr.net/gh/Arboding/blog@latest/images/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="卿词" href="https://arboding.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="卿词" href="https://arboding.github.io/atom.xml"><link rel="alternate" type="application/json" title="卿词" href="https://arboding.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/Arboding/blog@latest/css/app.css?v=0.2.5"><meta name="keywords" content="数据结构"><link rel="canonical" href="https://arboding.github.io/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC5%E7%AB%A0/%E6%A0%91/"><title>树 - 第5章 - 概念 - 数据结构 - 计算机 | Lumos Reverie = 卿词 = 仰望星空的人，总会比低头赶路的人看得更远</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">树</h1><div class="meta"><span class="item" title="创建时间：2025-01-12 15:51:01"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-01-12T15:51:01+08:00">2025-01-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>8.1k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/blog/" rel="start">Lumos Reverie</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://raw.githubusercontent.com/Arboding/picgo/main/img202501130028550.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/Arboding/picgo/main/img202501130028547.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/Arboding/picgo/main/img202501130028559.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/Arboding/picgo/main/img202501130028565.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/Arboding/picgo/main/img202501130028554.jpg"></li><li class="item" data-background-image="https://raw.githubusercontent.com/Arboding/picgo/main/img202501130028562.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/blog/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="item" rel="index" title="分类于 计算机"><span itemprop="name">计算机</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="item" rel="index" title="分类于 数据结构"><span itemprop="name">数据结构</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" itemprop="item" rel="index" title="分类于 概念"><span itemprop="name">概念</span></a><meta itemprop="position" content="3"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC5%E7%AB%A0/" itemprop="item" rel="index" title="分类于 第5章"><span itemprop="name">第5章</span></a><meta itemprop="position" content="4"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://arboding.github.io/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC5%E7%AB%A0/%E6%A0%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/Arboding/blog@latest/images/avatar.jpg"><meta itemprop="name" content="卿词"><meta itemprop="description" content="仰望星空的人，总会比低头赶路的人看得更远, "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="卿词"></span><div class="body md" itemprop="articleBody"><h2 id="一-树的概念与基本术语"><a class="anchor" href="#一-树的概念与基本术语">#</a> 一、树的概念与基本术语</h2><h3 id="1树的定义tree"><a class="anchor" href="#1树的定义tree">#</a> 1. 树的定义 (Tree)</h3><p>（1）树是有 n (n≥0) 个结点的有限集合。</p><p>（2）如果 n=0，称为空树；</p><p>（3）如果 n&gt;0, 称为非空树，对于非空树，有且仅有一个特定的称为根 (Root) 的节点 (无直接前驱)</p><p>（4）如果 n&gt;1，则除根以外的其它结点划分为 m (m&gt;0) 个互不相交的有限集 <code>T1, T2 ,…, Tm</code> ，其中每个集合本身又是一棵树，并且称为根的子树 ( <code>SubTree</code> )。(此为递归定义)</p><p>（5）每个结点都有唯一的直接前驱，但可能有多个后继。</p><p>（6）m &gt; 0 时，子树的个数是没有限制的，但是他们一定是互不相交的。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606771.png" alt="image-20250103183505596"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606772.png" alt="image-20250103183716766"></p><h3 id="2树的基本术语"><a class="anchor" href="#2树的基本术语">#</a> 2. 树的基本术语</h3><p>（1）结点：包含一个数据元素及若干指向其子树的分支；（包括分支！）</p><p>（2）结点的度：结点拥有的子树数；结点的深度是从根结点开始自顶向下逐层累加；结点的高度是从叶节点开始自底向上逐层累加。</p><p>（3）叶结点：度为 0 的结点 [没有子树的结点] (终端结点或叶结点 )</p><p>（4）分支结点：度不为 0 的结点 [包括根结点]，也称为非终端结点。除根外称为内部结点。</p><p>​	注意：度不为 0 的结点，除根之外都是内部结点！</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606773.png" alt="image-20250103183853153"></p><p>（5）孩子：结点的子树的根 [直接后继，可能有多个]</p><p>（6）双亲：孩子的直接前驱 [最多只能有一个]</p><p>（7）兄弟：同一双亲的孩子</p><p>（8）子孙：以某结点为根的树中的所有结点</p><p>（9）祖先：从根到该结点所经分支上的所有结点</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606774.png" alt="image-20250103183921949"></p><p>（10）层次：根结点为第一层，其孩子为第二层，依此类推</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606775.png" alt="image-20250103183943729"></p><p>（11）深度：树中结点的<strong>最大层次</strong>（从根算第一层），也为树的高度。</p><p>（12）有序树：子树之间存在确定的次序关系，不能互换的。</p><p>（13）无序树：子树之间不存在确定的次序关系。</p><p>（14）森林：互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。任何一棵非空树是一个二元组 Tree = （root，F）其中：root 被称为根结点 ，F 被称为子树森林。</p><p>3. 树型结构与线性结构的区别在于：一个元素可以有多个后继。<img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606776.png" alt="image-20250103184129326"></p><p>4. 树的相关性质：</p><p>（1）树中的结点数等于所有结点的度数加一</p><p>（2）度为 m 的树中第 i 层上至多有 <code>m^(i-1)</code> 个结点</p><p>（3）高度为 h 的 m 叉树至多有 (m^h-1)/(m-1) 个结点</p><p>（4）具有 n 个结点的 m 叉树的最小高度为 logm (n (m-1)+1)</p><h2 id="树的抽象数据类型"><a class="anchor" href="#树的抽象数据类型">#</a> 树的抽象数据类型</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre>ADT 树<span class="token punctuation">(</span>tree<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Data</pre></td></tr><tr><td data-num="3"></td><td><pre>    树是由一个根结点和若干棵子树构成的。树中结点具有相同数据类型及层次关系</pre></td></tr><tr><td data-num="4"></td><td><pre>Operation</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">InitTree</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">:</span>构造空树</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">DestroyTree</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">:</span>销毁树</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">CreateTree</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">,</span> definition<span class="token punctuation">)</span><span class="token operator">:</span>按definition中给出树的定义来构造树</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">ClearTree</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token operator">:</span>若树T存在，则将树T清为空树</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">TreeEmpty</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">:</span>判断是否为空树</pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token function">TreeDepth</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">:</span>返回T的深度</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">Root</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">:</span>返回T的根节点</pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token function">Value</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> cur_e<span class="token punctuation">)</span><span class="token operator">:</span>cur_e是树T中一个结点，返回此结点的值</pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">Assign</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> cur_e<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token operator">:</span>给树T的结点cur_e赋值为value</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">Parent</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> cur_e<span class="token punctuation">)</span><span class="token operator">:</span>若cur_e是树的非根节点，则返回它的双亲，否则返回空</pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">LeftChild</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> cur_e<span class="token punctuation">)</span><span class="token operator">:</span>若cur_e是树T的非叶节点，则返回它的最左孩子，否则返回空</pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">RightSibling</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> cur_e<span class="token punctuation">)</span><span class="token operator">:</span>若cur_e有右兄弟，则返回它的右兄弟，否则返回空</pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">InsertChild</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> i<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token operator">:</span>其中p指向树T的某个结点，i为所指结点p的度加上<span class="token number">1</span>，非空树c与T不相交，操作结果为插入c为数T中p所指结点的第i棵子树</pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token function">DeleteChild</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token operator">:</span>其中p指向数T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树</pre></td></tr><tr><td data-num="19"></td><td><pre>endADT</pre></td></tr></table></figure><h2 id="树的存储结构"><a class="anchor" href="#树的存储结构">#</a> 树的存储结构</h2><h3 id="1-双亲表示法"><a class="anchor" href="#1-双亲表示法">#</a> 1 双亲表示法</h3><p>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示器双亲结点在数组中的位置。<img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606777.png" alt="image-20250103190221059"></p><p>data 是数据域，存储结点的数据信息；parent 是指针域，存储该节点的双亲在数组中的下标。</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 树的双亲表示法结点结构定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TREE_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> TElemType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">PTNode</span><span class="token punctuation">&#123;</span>		<span class="token comment">// 结点结构</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    TElemType data<span class="token punctuation">;</span>			<span class="token comment">// 结点数据</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>				<span class="token comment">// 双亲位置</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span>PTNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>				<span class="token comment">// 树结构</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    PTNode nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 结点数组</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">int</span> r<span class="token punctuation">,</span> n<span class="token punctuation">;</span>				<span class="token comment">// 根的位置和结点数</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span>PTree<span class="token punctuation">;</span></pre></td></tr></table></figure><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ29vZF9nbG9yeS9waWNnby9yYXcvbWFzdGVyLzIwMjUwMTEyMTYwNjc3OC5wbmc=">https://gitee.com/good_glory/picgo/raw/master/202501121606778.png</span>&quot; alt=&quot;image-20250103190800310&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ29vZF9nbG9yeS9waWNnby9yYXcvbWFzdGVyLzIwMjUwMTEyMTYwNjc3OS5wbmc=">https://gitee.com/good_glory/picgo/raw/master/202501121606779.png</span>&quot; alt=&quot;image-20250103190819273&quot; style=&quot;zoom:50%;&quot; /&gt;</p><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vZ29vZF9nbG9yeS9waWNnby9yYXcvbWFzdGVyLzIwMjUwMTEyMTYwNjc4MC5wbmc=">https://gitee.com/good_glory/picgo/raw/master/202501121606780.png</span>&quot; alt=&quot;image-20250103190934620&quot; style=&quot;zoom: 50%;&quot; /&gt;</p><h3 id="2-孩子表示法"><a class="anchor" href="#2-孩子表示法">#</a> 2 孩子表示法</h3><p>换一种完全不同的考虑方法。由于树中的每个结点可能右多棵子树，可以考虑用多重链表，即每个结点右多个指针域，其中每个指针指向一颗子树的根结点，我们把这种方法叫做多重链表表示法。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606781.png" alt="image-20250103191541862"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606782.png" alt="image-20250103191639079"></p><p>优点：节省时间</p><p>缺点：浪费空间</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606783.png" alt="image-20250103191726395"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606784.png" alt="image-20250103191747487"></p><p>优点：节省空间</p><p>缺点：耗费时间</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 树的孩子表示法结构定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_TREE_SIZE</span> <span class="token expression"><span class="token number">100</span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> TElemType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CTNode</span><span class="token punctuation">&#123;</span>		<span class="token comment">// 孩子结点</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> child<span class="token punctuation">;</span>				<span class="token comment">// 用来存储某个结点在表头数组中的下标</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">CTNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>	<span class="token comment">// 用来存储指向某节点的下一个孩子结点的指针</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span>CTNode<span class="token punctuation">,</span> <span class="token operator">*</span>ChildPtr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>				<span class="token comment">// 表头结点</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    TElemType data<span class="token punctuation">;</span>			<span class="token comment">// 存储某结点的数据信息</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    ChildPtr firstchild<span class="token punctuation">;</span>	<span class="token comment">// 存储该结点的孩子链表的头指针</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span>CTBox<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>				<span class="token comment">// 树结构</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    CTBox nodes<span class="token punctuation">[</span>MAX_TREE_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 结点数组</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">int</span> r<span class="token punctuation">,</span> n<span class="token punctuation">;</span>				<span class="token comment">// 根的位置和结点数</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span>CTree<span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606785.png" alt="image-20250103202248518"></p><h3 id="3-孩子兄弟表示法"><a class="anchor" href="#3-孩子兄弟表示法">#</a> 3 孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606786.png" alt="image-20250103202646956"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 树的孩子兄弟表示法结构定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">CSNode</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    TElemType data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">CSNode</span> <span class="token operator">*</span>firstchld<span class="token punctuation">,</span> <span class="token operator">*</span>rightsib<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span>CSNode<span class="token punctuation">,</span> <span class="token operator">*</span>CSTree<span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606787.png" alt="image-20250103202857425"></p><p>其实这个表示法的最大好处是它把一棵复杂的树变成了一颗二叉树。</p><p>这样我们可以充分的利用二叉树的特性和算法来处理这棵树了。</p><h2 id="二叉树的定义"><a class="anchor" href="#二叉树的定义">#</a> 二叉树的定义</h2><p>** 二叉树：** 二叉树是 n (n&gt;=0) 结点的有限集合，该集合或者为空集 (称为空二叉树)，或者由一个根节点和两棵互不相交的，分别称为根结点的左子树和右子树的二叉树组成。</p><p>1. 二叉树是一种特殊的树，每个结点最多有 2 棵子树，子树有左右之分。</p><p>2. 在二叉树的第 i 层上最多有 2^(i-1) 个结点。</p><p>3. 深度为 k 的二叉树最多有 2^k-1 个结点。</p><p>4. 如果二叉树终端结点数为 <code>n0</code> (也为叶子结点数), 度为 2 的结点数为 <code>n2</code> , 则 <code>n0=n2+1</code></p><h2 id="特殊二叉树"><a class="anchor" href="#特殊二叉树">#</a> 特殊二叉树</h2><p>斜树：所有的结点都是只有左子树的二叉树叫做左斜树。所有结点都是右子树的二叉树叫右斜树。这两者统称为斜树。</p><h3 id="满二叉树"><a class="anchor" href="#满二叉树">#</a> 满二叉树</h3><p>在一棵二叉树中，如果所有分支点都存在左子树和右子树，并且所有叶子都在同一层，这样的二叉树称为满二叉树。</p><p>1. 一个深度为 k 且有 2^k-1 个结点的二叉树。</p><p>2. 每层上的结点数都是最大数。</p><p>3. 可以自上而下、自左至右连续编号。</p><p>4. 叶子只能出现在最下一层</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606788.png" alt="image-20250103204320237"></p><h3 id="完全二叉树"><a class="anchor" href="#完全二叉树">#</a> 完全二叉树</h3><p>对一颗具有 n 个结点的二叉树按层序编号，如果编号为 i (1&lt;=i&lt;=n) 的结点与同样深度的二叉树中的编号为 i 的结点在二叉树中的卫视完全相同，则这棵树称为完全二叉树。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606789.png" alt="image-20250103204757482"></p><p>1. 当且仅当每一个结点都与深度相同的满二叉树中编号从 1 到 n 的结点一一对应的二叉树。</p><p>2. 叶子结点只在最下两层上出现。</p><p>3. 左子树深度与右子树深度相等或大１。</p><p>4. 具有 n 个结点的完全二叉树，其深度为 <code>floor(log2(n)) +1</code></p><p>5. 在完全二叉树中，结点 i 的双亲为 i/2;</p><p>​	结点 i 的左孩子 <code>LCHILD(i)=2i;</code></p><p>​	结点 i 的右孩子 <code>RCHILD(i)=2i+1.</code></p><h2 id="二叉树的性质"><a class="anchor" href="#二叉树的性质">#</a> 二叉树的性质</h2><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606790.png" alt="image-20250103205315791"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606791.png" alt="image-20250103205538666"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606792.png" alt="image-20250103205339033"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606793.png" alt="image-20250103205357092"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606794.png" alt="image-20250103205628218"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606795.png" alt="image-20250103205411524"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606796.png" alt="image-20250103205423762"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606797.png" alt="image-20250103205751746"></p><h2 id="二叉树的存储结构"><a class="anchor" href="#二叉树的存储结构">#</a> 二叉树的存储结构</h2><h3 id="顺序存储"><a class="anchor" href="#顺序存储">#</a> 顺序存储</h3><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606798.png" alt="image-20250103205909941"></p><h3 id="二叉链表"><a class="anchor" href="#二叉链表">#</a> 二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606800.png" alt="image-20250103210150269"></p><pre><code class="language-CPP">//二叉树的二叉链表结点结构定义
typedef struct BiTNode&#123;
    TElemType data;				//结点数据
    struct BiTNode *lchild, *rchild;//左右孩子指针
&#125;BiTNode, *BiTree;
</code></pre><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606801.png" alt="image-20250103210416693"></p><h2 id="遍历二叉树"><a class="anchor" href="#遍历二叉树">#</a> 遍历二叉树</h2><p>1. 遍历二叉树：树的遍历就是按某种次序访问树中的结点，要求每个结点访问一次且仅访问一次（非线性结构线性化）。</p><p>2. 一个二叉树由根节点与左子树和右子树组成，设访问根结点用 D 表示，遍历左、右子树用 L、R 表示，如果规定先左子树后右子树，则共有三种组合</p><p>（1） <code>DLR [先序遍历]</code></p><p>​	规则是若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。<img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606802.png" alt="image-20250103210826866"></p><p>遍历的顺序为： <code>ABDGHCEIF</code></p><p>（2） <code>LDR [中序遍历]</code></p><p>​	规则是若树为空，则空操作返回，否则从根节点开始 (注意并不是先访问根节点)，中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606803.png" alt="image-20250103211201072"></p><p>遍历的顺序为： <code>GDHBAEICF</code></p><p>（3） <code>LRD [后序遍历]</code></p><p>​	规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根节点。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606804.png" alt="image-20250103211414203"></p><p>遍历的顺序为： <code>GHDBIEFCA</code></p><p>（4） <code>层序遍历</code></p><p>​	规则是若树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606805.png" alt="image-20250103211837759"></p><p>遍历的顺序为： <code>ABCDEFGHI</code></p><h3 id="前序遍历算法"><a class="anchor" href="#前序遍历算法">#</a> 前序遍历算法</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 二叉树的前序遍历递归算法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 初始条件：二叉树 T 存在</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 操作结果：前序递归遍历 T</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> T <span class="token operator">-></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 显示结点数据，可以更改为其他对结点的操作</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T <span class="token operator">-></span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 先序遍历左子树</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">PreOrderTraverse</span><span class="token punctuation">(</span>T <span class="token operator">-></span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 先序遍历右子树</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="中序遍历算法"><a class="anchor" href="#中序遍历算法">#</a> 中序遍历算法</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 二叉树的中序遍历递归算法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 初始条件：二叉树存在</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 操作结果：中序递归遍历 T</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T <span class="token operator">-></span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 中序遍历左子树</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> T <span class="token operator">-></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 显示结点数据</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T <span class="token operator">-></span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 中序遍历右子树</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="后序遍历算法"><a class="anchor" href="#后序遍历算法">#</a> 后序遍历算法</h3><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 二叉树的后序遍历递归算法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 初始条件：二叉树存在</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 操作结果：中序递归遍历 T</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>BiTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>T <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T <span class="token operator">-></span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 中序遍历左子树</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token function">InOrderTraverse</span><span class="token punctuation">(</span>T <span class="token operator">-></span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 中序遍历右子树</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> T <span class="token operator">-></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 显示结点数据</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="二叉树的建立"><a class="anchor" href="#二叉树的建立">#</a> 二叉树的建立</h2><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 按前序输入二叉树中的结点的值（一个字符）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">//# 表示空树，构建二叉链表表示二叉树 T</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token function">CreatBiTree</span><span class="token punctuation">(</span>BiTree <span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 通过指针传入</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    TElemType ch<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    ch <span class="token operator">=</span> str<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ch <span class="token operator">=</span> <span class="token char">'#'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token operator">*</span>T <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token operator">*</span>T <span class="token operator">=</span> <span class="token punctuation">(</span>BiTree<span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">Sizeof</span><span class="token punctuation">(</span>BiTNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>T<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            <span class="token function">exit</span><span class="token punctuation">(</span>OVERFLOW<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> data <span class="token operator">=</span> ch<span class="token punctuation">;</span>			<span class="token comment">// 生成根节点</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token function">CreatBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 构造左子树</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token function">CreatBiTree</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token operator">-></span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 构造右子树</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="线索二叉树"><a class="anchor" href="#线索二叉树">#</a> 线索二叉树</h2><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606806.png" alt="image-20250103220052207"></p><p>我们观察上图，会发现指针域并不是都充分利用了，有需许多的空指针的存在，这不是什么号的现象，应该想办法利用起来。</p><p>线索二叉树：我们把指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索线索二叉树</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606807.png" alt="image-20250103220515056"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606808.png" alt="image-20250103221108599"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 二叉树的二叉线索存储结构定义</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">char</span> TElemType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>Link<span class="token punctuation">,</span> Thread<span class="token punctuation">&#125;</span> PointerTag<span class="token punctuation">;</span><span class="token comment">//Link==0 表示指向左右孩子指针，thread==1 表示指向前驱或后继的线索</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span><span class="token punctuation">&#123;</span><span class="token comment">// 二叉线索存储结构</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    TElemType data<span class="token punctuation">;</span>		<span class="token comment">// 结点数据</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">BiThrNode</span> <span class="token operator">*</span>lchild<span class="token punctuation">,</span> <span class="token operator">*</span>rchild<span class="token punctuation">;</span><span class="token comment">// 左右孩子指针</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    PointerTag LTag<span class="token punctuation">;</span><span class="token comment">// 左右标志</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    PointerTag RTag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span>BiThrNode<span class="token punctuation">,</span> <span class="token operator">*</span>BiThrTree<span class="token punctuation">;</span></pre></td></tr></table></figure><p>线索化的过程就是在遍历的过程中修改空指针的过程</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 中序遍历线索化的递归函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre>BiThrTree pre<span class="token punctuation">;</span>		<span class="token comment">// 全局变量，始终指向刚刚访问过的结点</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 中序遍历进行中序线索化</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">InThreading</span><span class="token punctuation">(</span>BiThrTree p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p <span class="token operator">-></span> lchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 递归左子树线索化</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">-></span> lchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>		<span class="token comment">// 没有左孩子</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            p <span class="token operator">-></span> LTag <span class="token operator">=</span> Thread<span class="token punctuation">;</span><span class="token comment">// 前驱线索</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            p <span class="token operator">-></span> lchild <span class="token operator">=</span> Pre<span class="token punctuation">;</span><span class="token comment">// 左孩子指针指向前驱</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pre <span class="token operator">-></span> rchild<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">// 前驱没有右孩子</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            pre <span class="token operator">-></span> RTag <span class="token operator">=</span> Thread<span class="token punctuation">;</span><span class="token comment">// 线索化</span></pre></td></tr><tr><td data-num="13"></td><td><pre>            pre <span class="token operator">-></span> rchild <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">// 前驱右孩子指针指向后继（当前结点 p）</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        pre <span class="token operator">=</span> p<span class="token punctuation">;</span>			<span class="token comment">// 保持 pre 指向 p 的前驱</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        <span class="token function">InThreading</span><span class="token punctuation">(</span>p <span class="token operator">-></span> rchild<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 递归右子树线索化</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>线索二叉树的遍历<img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606809.png" alt="image-20250104133225134"></p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//T 指向头结点，头结点左链 lchild 指向根节点，头结点右链 rchild 指向中序遍历</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 最后一个结点，中序遍历二叉线索链表表示第二叉树</span></pre></td></tr><tr><td data-num="3"></td><td><pre>Status <span class="token function">InOrderTraverse_Thr</span><span class="token punctuation">(</span>BiThrTree T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    BiThrTree p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    p <span class="token operator">=</span> T <span class="token operator">-></span> lchild<span class="token punctuation">;</span>		<span class="token comment">//p 指向根节点</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>			<span class="token comment">// 空树或遍历结束时，p ==T</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">-></span> LTag <span class="token operator">==</span> Link<span class="token punctuation">)</span><span class="token comment">// 当 LTag==0 时循环到中序第一个结点</span></pre></td></tr><tr><td data-num="8"></td><td><pre>            p <span class="token operator">=</span> p <span class="token operator">-></span> lchild<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> p <span class="token operator">-></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 显示结点数据，可以更改为其他对结点的操作</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">-></span> RTag <span class="token operator">==</span> Thread <span class="token operator">&amp;&amp;</span> p <span class="token operator">-></span> rchild <span class="token operator">!=</span> T<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            p <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> p <span class="token operator">-></span> data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 访问后继结点</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        p <span class="token operator">=</span> p <span class="token operator">-></span> rchild<span class="token punctuation">;</span><span class="token comment">//p 进至其右子树根</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">return</span> OK<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>如果所用的二叉树需要经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择</p><h2 id="树-森林与二叉树的转换"><a class="anchor" href="#树-森林与二叉树的转换">#</a> 树、森林与二叉树的转换</h2><h3 id="树转换为二叉树"><a class="anchor" href="#树转换为二叉树">#</a> 树转换为二叉树</h3><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606810.png" alt="image-20250104134739485"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606811.png" alt="image-20250104134746056"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606812.png" alt="image-20250104134753720"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606813.png" alt="image-20250104134802243"></p><h3 id="森林转换为二叉树"><a class="anchor" href="#森林转换为二叉树">#</a> 森林转换为二叉树</h3><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606814.png" alt="image-20250104134858486"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606815.png" alt="image-20250104134922464"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606816.png" alt="image-20250104134929211"></p><h3 id="二叉树转换为树"><a class="anchor" href="#二叉树转换为树">#</a> 二叉树转换为树</h3><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606817.png" alt="image-20250104135120697"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606818.png" alt="image-20250104135126713"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606819.png" alt="image-20250104135132655"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606820.png" alt="image-20250104135139353"></p><h3 id="二叉树转换为森林"><a class="anchor" href="#二叉树转换为森林">#</a> 二叉树转换为森林</h3><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606821.png" alt="image-20250104135246001"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606822.png" alt="image-20250104135252920"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606823.png" alt="image-20250104135258137"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606824.png" alt="image-20250104135304049"></p><p>（1）在有 <code>n</code> 个结点的二叉树中，必定存在 <code>n+1</code> 个空链域；</p><p>（2）因为每个结点有两个链域（左、右孩子指针），因此共有 <code>2n</code> 个链域；</p><p>（3）除根结点外，每个结点都有且仅有一个分支相连，即 <code>n-1</code> 个链域被使用。</p><h2 id="树与森林"><a class="anchor" href="#树与森林">#</a> 树与森林</h2><p>1. 树的存储结构</p><p>（1）双亲表示法：采用一组连续的存储空间；由于每个结点只有一个双亲，只需要一个指针。<img data-src="https://i-blog.csdnimg.cn/blog_migrate/14534fe942e56381de7a12ec1b1fad8a.png" alt="img"></p><p>（2）孩子表示法：可以采用多重链表，即每个结点有多个指针，最大缺点是空链域太多 [(d-1) n+1 个]。将每个结点的孩子排列起来，用单链表表示；将每个结点排列成一个线性表。<img data-src="https://i-blog.csdnimg.cn/blog_migrate/e48970eaff818db8ba39af07ad1da42d.png" alt="img"></p><p>（3）孩子兄弟表示法（常用）：采用二叉链表左边指针指向第一个孩子，右边指针指向兄弟。<img data-src="https://i-blog.csdnimg.cn/blog_migrate/8534f045d3416d9f80456e392b98a81c.png" alt="img"></p><p>2. 树与二叉树的对于关系</p><p>（1）树与二叉树都可以采用二叉链表作存储结构。</p><p>（2）任意给定一棵树，可以找到一个唯一的二叉树 (没有右子树)。</p><p><img data-src="https://i-blog.csdnimg.cn/blog_migrate/e59356587a1801aae6c1ac38588d5e37.png" alt="img"><img data-src="https://i-blog.csdnimg.cn/blog_migrate/d8f5145c4fd5a4606ecb16653b7d7281.png" alt="img"></p><p>3. 森林与二叉树的对应关系</p><p>4. 树的遍历：</p><p>（1）先根（次序）遍历（树的先根 ----- 二叉树的先序）</p><p><img data-src="https://i-blog.csdnimg.cn/blog_migrate/17cfdc5def54dadd0bb73b28512a9adb.png" alt="img"></p><p>（2）后根（次序）遍历（树的后根 ----- 二叉树的中序）</p><p><img data-src="https://i-blog.csdnimg.cn/blog_migrate/63e5036c2fcce2ebe01fa2615b36c67c.png" alt="img"></p><p>5. 森林的遍历：</p><p>（1）先序遍历：依次从左至右对森林中的每一棵树进行先根遍历。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606825.png" alt="image-20250104140014208"></p><p>（2）中序遍历：依次从左至右对森林中的每一棵树进行后根遍历。</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606826.png" alt="image-20250104140046204"></p><h2 id="赫夫曼树及其应用"><a class="anchor" href="#赫夫曼树及其应用">#</a> 赫夫曼树及其应用</h2><p>1. 最优二叉树</p><p>（1）路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径</p><p>（2）路径长度：路径上的分支数目</p><p>（3）树的路径长度：从树根到每个结点的路径长度之和</p><p>（4）结点的带权路径长度：从结点到树根之间的路径长度与结点上权的乘积</p><p>（5）树的带权路径长度 ( <code>WPL</code> )：树中所有叶子结点的带权路径长度之和（是叶子结点！）</p><p>（6）最优二叉树：假设二叉树有 n 个叶子，其每个叶子结点带权 <code>wi</code> ，则带权路径长度 <code>WPL</code> 最小的二叉树称为最优二叉树</p><p>（7）赫夫曼 (Huffman) 树就是一棵最优二叉树</p><p>2. 赫夫曼树</p><p>（1）在 Huffman 树中，权值最大的结点离根最近；权值最小的结点离根最远。</p><p>（2）构建算法：</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606827.png" alt="image-20250104144826129"><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606828.png" alt="image-20250104144838877"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606829.png" alt="image-20250104145019658"></p><p>注意：画图时每一次要把所有点都画出来！</p><h3 id="哈夫曼编码"><a class="anchor" href="#哈夫曼编码">#</a> 哈夫曼编码</h3><p>当初，哈夫曼研究这种最优树的目的是为了解决当年远距离通信的数据传输的最优化问题<img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606830.png" alt="image-20250104145519779"></p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606831.png" alt="image-20250104145730572"></p><p>构造好哈夫曼树之后将权值左分支改为 0，右分支改为 1 后的哈夫曼树</p><p>​	1. 从 Huffman 树的每一个叶子结点开始</p><p>​	2、依次沿结点到根的路径，判断该结点是父亲结点的左孩子还是右孩子，如果是左	孩子则得到编码‘0’，否则得到编码‘1’，先得到的编码放在后面</p><p>​	3、直到到达根结点，编码序列即为该叶子结点对应的 Huffman 编码</p><p><img data-src="https://gitee.com/good_glory/picgo/raw/master/202501121606832.png" alt="image-20250104145829382"></p><p>（4）译码算法：</p><p>​	1. 指针指向 Huffman 树的根结点，取第一个 Huffman 码</p><p>​	2、如果 Huffman 码为‘0’，将指针指向当前结点的左子树的根结点；如果 Huffman	码为‘1’，将指针指向当前结点的右子树的根结点</p><p>​	3、如果指针指向的当前结点为叶子结点，则输出叶子结点对应的字符；否则，取下	一个 Huffman 码，并返回 2</p><p>​	4、如果 Huffman 码序列未结束，则返回 1 继续译码</p><p>Huffman 是一种前缀编码，解码时不会混淆</p><p>如 GOOD 编码为：01011001</p><p>如 Huffman 编码序列 01011001，译码后的字符串为 GOOD</p><p>（5）前缀编码：指的是，任何一个字符的编码都不是同一字符集中另一个字符的编码的前缀。利用赫夫曼树可以构造一种不等长的二进制编码，并且构造所得的赫夫曼编码是一种最优前缀编码，即使所传电文的总长度最短。</p><p>已知一颗完全二叉树第 7 层有 20 个结点，则整棵树的结点数？</p><p>​	83</p><p>​	第 i 层最多有 2 的 (i-1) 次方个</p><p>​	深度为 k 的满二叉树结点有 2 的 i 次方 - 1 个</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d5ZW9saGFkYS9hcnRpY2xlL2RldGFpbHMvMTM1NTEzNDg3">参考链接</span></p><div class="tags"><a href="/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="ic i-tag"></i> 数据结构</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-01-12 16:18:10" itemprop="dateModified" datetime="2025-01-12T16:18:10+08:00">2025-01-12</time> </span><span id="2025/01/12/计算机/数据结构/概念/第5章/树/" class="item leancloud_visitors" data-flag-title="树" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>卿词 <i class="ic i-at"><em>@</em></i>卿词</li><li class="link"><strong>本文链接：</strong> <a href="https://arboding.github.io/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC5%E7%AB%A0/%E6%A0%91/" title="树">https://arboding.github.io/2025/01/12/计算机/数据结构/概念/第5章/树/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC4%E7%AB%A0/1.%E4%B8%B2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Arboding&#x2F;picgo&#x2F;main&#x2F;img202501130028548.jpg" title="串"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 第4章</span><h3>串</h3></a></div><div class="item right"><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC6%E7%AB%A0/%E5%9B%BE/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Arboding&#x2F;picgo&#x2F;main&#x2F;img202501130028563.jpg" title="图"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 第6章</span><h3>图</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text">一、树的概念与基本术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89tree"><span class="toc-number">1.1.</span> <span class="toc-text">1. 树的定义 (Tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.2.</span> <span class="toc-text">2. 树的基本术语</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">树的抽象数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">1 双亲表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">2 孩子表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">3 孩子兄弟表示法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">特殊二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">完全二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">7.1.</span> <span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">7.2.</span> <span class="toc-text">二叉链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">前序遍历算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">中序遍历算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">后序遍历算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">9.</span> <span class="toc-text">二叉树的建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">10.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91-%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.</span> <span class="toc-text">树、森林与二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">11.1.</span> <span class="toc-text">树转换为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">11.2.</span> <span class="toc-text">森林转换为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="toc-number">11.3.</span> <span class="toc-text">二叉树转换为树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">11.4.</span> <span class="toc-text">二叉树转换为森林</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97"><span class="toc-number">12.</span> <span class="toc-text">树与森林</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">13.</span> <span class="toc-text">赫夫曼树及其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">13.1.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC5%E7%AB%A0/%E6%A0%91/" rel="bookmark" title="树">树</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="卿词" data-src="//cdn.jsdelivr.net/gh/Arboding/blog@latest/images/avatar.jpg"><p class="name" itemprop="name">卿词</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/blog/archives/"><span class="count">10</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/blog/categories/"><span class="count">12</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/blog/tags/"><span class="count">2</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyYm9kaW5n" title="https:&#x2F;&#x2F;github.com&#x2F;Arboding"><i class="ic i-github"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS81MS0xOS0yMC00OQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;51-19-20-49"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTM4NzAxNzAwOA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;387017008"><i class="ic i-cloud-music"></i></span> <a href="/blog/2054424479@qq.com" title="2054424479@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/blog/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/blog/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/blog/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/blog/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/blog/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/blog/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/blog/links/" rel="section"><i class="ic i-magic"></i>links</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC4%E7%AB%A0/1.%E4%B8%B2/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC6%E7%AB%A0/%E5%9B%BE/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC2%E7%AB%A0/" title="分类于 第2章">第2章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC2%E7%AB%A0/%E7%BA%BF%E6%80%A7%E8%A1%A8/" title="线性表">线性表</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC1%E7%AB%A0/" title="分类于 第1章">第1章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0/2.%E7%AE%97%E6%B3%95/" title="2.算法">2.算法</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/tool/" title="分类于 tool">tool</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/tool/hexo/" title="分类于 hexo">hexo</a></div><span><a href="/blog/2025/01/12/tool/hexo/hexo/" title="hexo的使用">hexo的使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC6%E7%AB%A0/" title="分类于 第6章">第6章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC6%E7%AB%A0/%E5%9B%BE/" title="图">图</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC4%E7%AB%A0/" title="分类于 第4章">第4章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC4%E7%AB%A0/1.%E4%B8%B2/" title="串">串</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC7%E7%AB%A0/" title="分类于 第7章">第7章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC7%E7%AB%A0/%E6%9F%A5%E6%89%BE/" title="查找">查找</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC5%E7%AB%A0/" title="分类于 第5章">第5章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC5%E7%AB%A0/%E6%A0%91/" title="树">树</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC3%E7%AB%A0/" title="分类于 第3章">第3章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC3%E7%AB%A0/2.%20%E9%98%9F%E5%88%97/" title="1.队列">1.队列</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC3%E7%AB%A0/" title="分类于 第3章">第3章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC3%E7%AB%A0/1.%20%E6%A0%88/" title="1.栈">1.栈</a></span></li><li class="item"><div class="breadcrumb"><a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="分类于 计算机">计算机</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/" title="分类于 概念">概念</a> <i class="ic i-angle-right"></i> <a href="/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E7%AC%AC1%E7%AB%A0/" title="分类于 第1章">第1章</a></div><span><a href="/blog/2025/01/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A6%82%E5%BF%B5/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/%E7%AC%AC1%E7%AB%A0/1.%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%9C%AF%E8%AF%AD/" title="1.基本概念及术语">1.基本概念及术语</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">卿词 @ Lumos Reverie</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">64k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">58 分钟</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/01/12/计算机/数据结构/概念/第5章/树/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/Arboding/blog@latest/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->